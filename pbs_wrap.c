/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.10u-20011207-1933
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

typedef void *(*swig_converter_func)(void *);

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
  void                   *clientdata;	
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
SWIGEXPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGEXPORT(void) SWIG_TypeClientData(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}
#endif




/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include <stdlib.h>
#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink();
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(int)               SWIG_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGEXPORT(char *)            SWIG_PackData(char *c, void *, int);
SWIGEXPORT(char *)            SWIG_UnpackData(char *c, void *, int);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *,int own);
SWIGEXPORT(PyObject *)        SWIG_NewPackedObj(void *, int sz, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);
SWIGEXPORT(PyObject *)        SWIG_MakeShadow(PyObject *robj, swig_type_info *type, int own);
#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) Py_DECREF(obj);
      return 0;
    } else {
      if (newref) Py_DECREF(obj);
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) Py_DECREF(obj);
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }
  return 0;

type_error:
  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[512];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue("(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (own) {
      PyObject *n = PyInt_FromLong(1);
      PyObject_SetAttrString(inst,"thisown",n);
      Py_DECREF(n);
    }
    robj = inst;
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_MakeShadow(PyObject *robj, swig_type_info *type, int own) {
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyInstanceObject *inst;
    inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
    if (!inst) return robj;
    inst->in_dict = PyDict_New();
    inst->in_class = (PyClassObject *) type->clientdata;
    Py_INCREF(inst->in_class);
    PyObject_SetAttrString((PyObject *)inst,"this",robj);
    Py_DECREF(robj);
    if (own) {
      PyObject *n = PyInt_FromLong(1);
      PyObject_SetAttrString((PyObject *)inst,"thisown",n);
      Py_DECREF(n);
    }
    robj = (PyObject *) inst;
    Py_INCREF(robj);
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif








/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_batch_status swig_types[0] 
#define  SWIGTYPE_p_resource_t swig_types[1] 
#define  SWIGTYPE_p_float swig_types[2] 
#define  SWIGTYPE_p_double swig_types[3] 
#define  SWIGTYPE_p_char swig_types[4] 
#define  SWIGTYPE_p_p_char swig_types[5] 
#define  SWIGTYPE_p_attropl swig_types[6] 
#define  SWIGTYPE_p_long swig_types[7] 
#define  SWIGTYPE_p_attrl swig_types[8] 
#define  SWIGTYPE_p_void swig_types[9] 
#define  SWIGTYPE_p_int swig_types[10] 
#define  SWIGTYPE_p_short swig_types[11] 
static swig_type_info *swig_types[13];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= pbsc.so
  ------------------------------------------------*/
#define SWIG_init    initpbsc

#define SWIG_name    "pbsc"

#include <ctype.h>

/* Types used by the library */
static swig_type_info *SWIG_POINTER_int_p = 0;
static swig_type_info *SWIG_POINTER_short_p =0;
static swig_type_info *SWIG_POINTER_long_p = 0;
static swig_type_info *SWIG_POINTER_float_p = 0;
static swig_type_info *SWIG_POINTER_double_p = 0;
static swig_type_info *SWIG_POINTER_char_p = 0;
static swig_type_info *SWIG_POINTER_char_pp = 0;



/*------------------------------------------------------------------
  ptrvalue(ptr,type = 0)

  Attempts to dereference a pointer value.  If type is given, it 
  will try to use that type.  Otherwise, this function will attempt
  to "guess" the proper datatype by checking against all of the 
  builtin C datatypes. 
  ------------------------------------------------------------------ */

static PyObject *ptrvalue(PyObject *_PTRVALUE, int index, char *type) {
  void     *ptr;
  char     *s;
  PyObject *obj;

  if (SWIG_ConvertPtr(_PTRVALUE,&ptr,0,0)) {
    PyErr_SetString(PyExc_TypeError,"Type error in ptrvalue. Argument is not a valid pointer value.");
    return NULL;
  }

  /* If no datatype was passed, try a few common datatypes first */
  if (!type) {
    /* No datatype was passed.   Type to figure out if it's a common one */
    if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_int_p,0)) {
      type = "int";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_double_p,0)) {
      type = "double";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_short_p,0)) {
      type = "short";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_long_p,0)) {
      type = "long";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_float_p,0)) {
      type = "float";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_char_p,0)) {
      type = "char";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_char_pp,0)) {
      type = "char *";
    } else {
      type = "unknown";
    }
  }
  if (!ptr) {
    PyErr_SetString(PyExc_TypeError,"Unable to dereference NULL pointer.");
    return NULL;
  }
  /* Now we have a datatype.  Try to figure out what to do about it */
  if (strcmp(type,"int") == 0) {
    obj = PyInt_FromLong((long) *(((int *) ptr) + index));
  } else if (strcmp(type,"double") == 0) {
    obj = PyFloat_FromDouble((double) *(((double *) ptr)+index));
  } else if (strcmp(type,"short") == 0) {
    obj = PyInt_FromLong((long) *(((short *) ptr)+index));
  } else if (strcmp(type,"long") == 0) {
    obj = PyInt_FromLong((long) *(((long *) ptr)+index));
  } else if (strcmp(type,"float") == 0) {
    obj = PyFloat_FromDouble((double) *(((float *) ptr)+index));
  } else if (strcmp(type,"char") == 0) {
    obj = PyString_FromString(((char *) ptr)+index);
  } else if (strcmp(type,"char *") == 0) {
    char *c = *(((char **) ptr)+index);
    if (c) obj = PyString_FromString(c);
    else obj = PyString_FromString("NULL");
  } else {
    PyErr_SetString(PyExc_TypeError,"Unable to dereference unsupported datatype.");
    return NULL;
  }
  return obj;
}

/*------------------------------------------------------------------
  ptrcreate(type,value = 0,numelements = 1)

  Attempts to create a new object of given type.  Type must be
  a basic C datatype.  Will not create complex objects.
  ------------------------------------------------------------------ */

static PyObject *ptrcreate(char *type, PyObject *_PYVALUE, int numelements) {
  void     *ptr;
  PyObject *obj;
  int       sz;
  swig_type_info *cast;
  char      temp[40];

  /* Check the type string against a variety of possibilities */

  if (strcmp(type,"int") == 0) {
    sz = sizeof(int)*numelements;
    cast = SWIG_POINTER_int_p;
  } else if (strcmp(type,"short") == 0) {
    sz = sizeof(short)*numelements;
    cast = SWIG_POINTER_short_p;
  } else if (strcmp(type,"long") == 0) {
    sz = sizeof(long)*numelements;
    cast = SWIG_POINTER_long_p;
  } else if (strcmp(type,"double") == 0) {
    sz = sizeof(double)*numelements;
    cast = SWIG_POINTER_double_p;
  } else if (strcmp(type,"float") == 0) {
    sz = sizeof(float)*numelements;
    cast = SWIG_POINTER_float_p;
  } else if (strcmp(type,"char") == 0) {
    sz = sizeof(char)*numelements;
    cast = SWIG_POINTER_char_p;
  } else if (strcmp(type,"char *") == 0) {
    sz = sizeof(char *)*(numelements+1);
    cast = SWIG_POINTER_char_pp;
  } else {
    PyErr_SetString(PyExc_TypeError,"Unable to create unknown datatype."); 
    return NULL;
  }
   
  /* Create the new object */
  
  ptr = (void *) calloc(1,sz);
  if (!ptr) {
    PyErr_SetString(PyExc_MemoryError,"Out of memory in swig_create."); 
    return NULL;
  }

  /* Now try to set its default value */

  if (_PYVALUE) {
    if (strcmp(type,"int") == 0) {
      int *ip,i,ivalue;
      ivalue = (int) PyInt_AsLong(_PYVALUE);
      ip = (int *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"short") == 0) {
      short *ip,ivalue;
      int i;
      ivalue = (short) PyInt_AsLong(_PYVALUE);
      ip = (short *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"long") == 0) {
      long *ip,ivalue;
      int i;
      ivalue = (long) PyInt_AsLong(_PYVALUE);
      ip = (long *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"double") == 0) {
      double *ip,ivalue;
      int i;
      ivalue = (double) PyFloat_AsDouble(_PYVALUE);
      ip = (double *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"float") == 0) {
      float *ip,ivalue;
      int i;
      ivalue = (float) PyFloat_AsDouble(_PYVALUE);
      ip = (float *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"char") == 0) {
      char *ip,*ivalue;
      ivalue = (char *) PyString_AsString(_PYVALUE);
      ip = (char *) ptr;
      strncpy(ip,ivalue,numelements-1);
    } else if (strcmp(type,"char *") == 0) {
      char **ip, *ivalue;
      int  i;
      ivalue = (char *) PyString_AsString(_PYVALUE);
      ip = (char **) ptr;
      for (i = 0; i < numelements; i++) {
	if (ivalue) {
	  ip[i] = (char *) malloc(strlen(ivalue)+1);
	  strcpy(ip[i],ivalue);
	} else {
	  ip[i] = 0;
	}
      }
      ip[numelements] = 0;
    }
  } 
  /* Create the pointer value */
  
  obj = SWIG_NewPointerObj(ptr,cast,0);
  return obj;
}


/*------------------------------------------------------------------
  ptrset(ptr,value,index = 0,type = 0)

  Attempts to set the value of a pointer variable.  If type is
  given, we will use that type.  Otherwise, we'll guess the datatype.
  ------------------------------------------------------------------ */

static PyObject *ptrset(PyObject *_PTRVALUE, PyObject *_PYVALUE, int index, char *type) {
  void     *ptr;
  PyObject *obj;

  if (SWIG_ConvertPtr(_PTRVALUE,&ptr,0,0)) {
    PyErr_SetString(PyExc_TypeError,"Type error in ptrset. Argument is not a valid pointer value.");
    return NULL;
  }

  /* If no datatype was passed, try a few common datatypes first */
  if (!type) {
    /* No datatype was passed.   Type to figure out if it's a common one */
    if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_int_p,0)) {
      type = "int";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_double_p,0)) {
      type = "double";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_short_p,0)) {
      type = "short";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_long_p,0)) {
      type = "long";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_float_p,0)) {
      type = "float";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_char_p,0)) {
      type = "char";
    } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_char_pp,0)) {
      type = "char *";
    } else {
      type = "unknown";
    }
  }
  if (!ptr) {
    PyErr_SetString(PyExc_TypeError,"Unable to set NULL pointer.");
    return NULL;
  }
  
  /* Now we have a datatype.  Try to figure out what to do about it */
  if (strcmp(type,"int") == 0) {
    *(((int *) ptr)+index) = (int) PyInt_AsLong(_PYVALUE);
  } else if (strcmp(type,"double") == 0) {
    *(((double *) ptr)+index) = (double) PyFloat_AsDouble(_PYVALUE);
  } else if (strcmp(type,"short") == 0) {
    *(((short *) ptr)+index) = (short) PyInt_AsLong(_PYVALUE);
  } else if (strcmp(type,"long") == 0) {
    *(((long *) ptr)+index) = (long) PyInt_AsLong(_PYVALUE);
  } else if (strcmp(type,"float") == 0) {
    *(((float *) ptr)+index) = (float) PyFloat_AsDouble(_PYVALUE);
  } else if (strcmp(type,"char") == 0) {
    char *c = PyString_AsString(_PYVALUE);
    strcpy(((char *) ptr)+index, c);
  } else if (strcmp(type,"char *") == 0) {
    char *c = PyString_AsString(_PYVALUE);
    char **ca = (char **) ptr;
    if (ca[index]) free(ca[index]);
    if (strcmp(c,"NULL") == 0) {
      ca[index] = 0;
    } else {
      ca[index] = (char *) malloc(strlen(c)+1);
      strcpy(ca[index],c);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,"Unable to set unsupported datatype.");
    return NULL;
  }
  Py_INCREF(Py_None);
  return Py_None;
}

/*------------------------------------------------------------------
  ptradd(ptr,offset)

  Adds a value to an existing pointer value.  Will do a type-dependent
  add for basic datatypes.  For other datatypes, will do a byte-add.
  ------------------------------------------------------------------ */

static PyObject *ptradd(PyObject *_PTRVALUE, int offset) {

  char *r;
  void *ptr,*junk;
  PyObject *obj;
  swig_type_info *type;

  /* Check to see what kind of object _PTRVALUE is */
  
  /* Try to handle a few common datatypes first */
  if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_int_p,0)) {
    ptr = (void *) (((int *) ptr) + offset);
    type = SWIG_POINTER_int_p;
  } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_double_p,0)) {
    ptr = (void *) (((double *) ptr) + offset);
    type = SWIG_POINTER_double_p;
  } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_short_p,0)) {
    ptr = (void *) (((short *) ptr) + offset);
    type = SWIG_POINTER_short_p;
  } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_long_p,0)) {
    ptr = (void *) (((long *) ptr) + offset);
    type = SWIG_POINTER_long_p;
  } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_float_p,0)) {
    ptr = (void *) (((float *) ptr) + offset);
    type = SWIG_POINTER_float_p;
  } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_char_p,0)) {
    ptr = (void *) (((char *) ptr) + offset);
    type = SWIG_POINTER_char_p;
  } else if (!SWIG_ConvertPtr(_PTRVALUE,&ptr,SWIG_POINTER_char_pp,0)) {
    ptr = (void *) (((char *) ptr) + offset);
    type = SWIG_POINTER_char_pp;
  } else {
    PyErr_SetString(PyExc_TypeError,"Type error in ptradd. Argument is not a valid pointer value.");
    return NULL;
  }
  obj = SWIG_NewPointerObj(ptr, type,0);
  return obj;
}

/*------------------------------------------------------------------
  ptrfree(ptr)

  Destroys a pointer value
  ------------------------------------------------------------------ */

PyObject *ptrfree(PyObject *_PTRVALUE) {
  void *ptr, *junk;

  if (SWIG_ConvertPtr(_PTRVALUE,&ptr,0,0)) {
    PyErr_SetString(PyExc_TypeError,"Type error in ptrfree. Argument is not a valid pointer value.");
    return NULL;
  }
  
  /* Check to see if this pointer is a char ** */
  if (!SWIG_ConvertPtr(_PTRVALUE,&junk,SWIG_POINTER_char_pp,0)) {
    char **c = (char **) ptr;
    if (c) {
      int i = 0;
      while (c[i]) {
	free(c[i]);
	i++;
      }
    }
  }
  if (ptr)
    free((char *) ptr);

  Py_INCREF(Py_None);
  return Py_None;
}




#include "pbs_ifl.h"
#include "pbs_error.h"



int Get_List_Size(PyObject *src)
{
  if (PyList_Check(src))
    return(PyList_Size(src));
  else {

    /* check if valid NULL pointer */
    if ( PyString_Check(src) ) {
      if ( ! strcmp(PyString_AsString(src), "NULL") )
        return(0);
    }
    else
      return(-1);

  } // end else
} // end Get_List_Size()




// The default constructor for struct attrl
//
struct attrl *new_attrl(int number)
{
  struct attrl *ptr;
  struct attrl *prev, *current;
  int i;

  /* 
    allocate memory as a one block is handy for Python scripts 
    and fill in the next fields so it also works for the C-library
  */
  ptr = (struct attrl *) malloc(number * sizeof(struct attrl));

  prev = NULL;
  current = ptr + (number - 1);
  for (i=0; i < number; i++)
  { 
    // printf("constructor called\n");
    current->name     = (char *) malloc(MAXNAMLEN * sizeof(char));
    current->resource = (char *) malloc(MAXNAMLEN * sizeof(char));
    current->value    = (char *) malloc(MAXNAMLEN * sizeof(char));

    bzero( (void*) current->name, sizeof(current->name));
    bzero( (void*) current->resource, sizeof(current->resource));
    bzero( (void*) current->value, sizeof(current->value));

    current->next     = prev;
    prev = current;
    current--;
  }
  return (struct attrl *)ptr;

} // end new_attrl()


// The default constructor for struct attropl
//
struct attropl *new_attropl(int number)
{
  struct attropl *ptr;
  struct attropl *prev, *current;
  int i;

  /* 
    allocate memory as a one block is handy for Python scripts 
    and fill in the next fields so it also works for the C-library
  */
  ptr = (struct attropl *) malloc(number * sizeof(struct attropl));

  prev = NULL;
  current = ptr + (number - 1);
  for (i=0; i < number; i++)
  { 
    // printf("constructor called\n");
    current->name     = (char *) malloc(MAXNAMLEN * sizeof(char));
    current->resource = (char *) malloc(MAXNAMLEN * sizeof(char));
    current->value    = (char *) malloc(MAXNAMLEN * sizeof(char));

    bzero( (void*) current->name, sizeof(current->name));
    bzero( (void*) current->resource, sizeof(current->resource));
    bzero( (void*) current->value, sizeof(current->value));
    current->op = 0;

    current->next     = prev;
    prev = current;
    current--;
  }
  return (struct attropl *)ptr;

} // end new_attropl()

/* Not used only returned */
struct batch_status *new_batch_status()
{
   struct batch_status *ptr;

   ptr = (struct batch_status *) malloc(sizeof(struct batch_status));
   return (struct batch_status *)ptr;
} // end new struct batch_status


extern int pbs_errno;
extern char *pbs_server;
extern char avail(int ,char *);
extern int pbs_asyrunjob(int ,char *,char *,char *);
extern int pbs_alterjob(int ,char *,struct attrl *,char *);
extern int pbs_connect(char *);
extern int pbs_query_max_connections();
extern char *pbs_default(void );
extern int pbs_deljob(int ,char *,char *);
extern int pbs_disconnect(int );
extern char *pbs_geterrmsg(int );
extern int pbs_holdjob(int ,char *,char *,char *);
extern char *pbs_locjob(int ,char *,char *);
extern int pbs_manager(int ,int ,int ,char *,struct attropl *,char *);
extern int pbs_movejob(int ,char *,char *,char *);
extern int pbs_msgjob(int ,char *,int ,char *,char *);
extern int pbs_orderjob(int ,char *,char *,char *);
extern int pbs_rescquery(int ,char **,int ,int *,int *,int *,int *);
extern int pbs_rescreserve(int ,char **,int ,resource_t *);
extern int pbs_rescrelease(int ,resource_t );
extern int pbs_rerunjob(int ,char *,char *);
extern int pbs_rlsjob(int ,char *,char *,char *);
extern int pbs_runjob(int ,char *,char *,char *);
extern char **pbs_selectjob(int ,struct attropl *,char *);
extern int pbs_sigjob(int ,char *,char *,char *);
extern void pbs_statfree(struct batch_status *);
extern struct batch_status *pbs_statjob(int ,char *,struct attrl *,char *);
extern struct batch_status *pbs_selstat(int ,struct attropl *,char *);
extern struct batch_status *pbs_statque(int ,char *,struct attrl *,char *);
extern struct batch_status *pbs_statserver(int ,struct attrl *,char *);
extern struct batch_status *pbs_statnode(int ,char *,struct attrl *,char *);
extern char *pbs_submit(int ,struct attropl *,char *,char *,char *);
extern int pbs_terminate(int ,int ,char *);
extern int totpool(int ,int );
extern int usepool(int ,int );
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_ptrvalue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PyObject *arg1 ;
    int arg2 = 0 ;
    char *arg3 = 0 ;
    PyObject *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|is:ptrvalue",&obj0,&arg2,&arg3)) return NULL;
    {
        arg1 = obj0;
    }
    result = (PyObject *)ptrvalue(arg1,arg2,arg3);
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_ptrset(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PyObject *arg1 ;
    PyObject *arg2 ;
    int arg3 = 0 ;
    char *arg4 = 0 ;
    PyObject *result;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|is:ptrset",&obj0,&obj1,&arg3,&arg4)) return NULL;
    {
        arg1 = obj0;
    }
    {
        arg2 = obj1;
    }
    result = (PyObject *)ptrset(arg1,arg2,arg3,arg4);
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_ptrcreate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PyObject *arg2 = 0 ;
    int arg3 = 1 ;
    PyObject *result;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"s|Oi:ptrcreate",&arg1,&obj1,&arg3)) return NULL;
    if (obj1)
    {
        arg2 = obj1;
    }
    result = (PyObject *)ptrcreate(arg1,arg2,arg3);
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_ptrfree(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PyObject *arg1 ;
    PyObject *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ptrfree",&obj0)) return NULL;
    {
        arg1 = obj0;
    }
    result = (PyObject *)ptrfree(arg1);
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_ptradd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PyObject *arg1 ;
    int arg2 ;
    PyObject *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ptradd",&obj0,&arg2)) return NULL;
    {
        arg1 = obj0;
    }
    result = (PyObject *)ptradd(arg1,arg2);
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_new_attrl(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    struct attrl *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:new_attrl",&arg1)) return NULL;
    result = (struct attrl *)new_attrl(arg1);
    {
        PyObject	*obj_batch;
        struct attrl	*ptr;
        int		i=0, len=0;
        
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_attrl,1); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_new_attropl(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    struct attropl *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:new_attropl",&arg1)) return NULL;
    result = (struct attropl *)new_attropl(arg1);
    {
        PyObject		*obj_batch;
        struct attropl	*ptr;
        int			i=0, len=0;
        
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_attropl,1); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_new_batch_status(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_batch_status")) return NULL;
    result = (struct batch_status *)new_batch_status();
    {
        PyObject *obj_batch;
        struct batch_status *ptr;
        int i=0, len=0;
        
        // printf("Ja we are in bussniss\n");
        
        // Deterime length of list
        //
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        // Make a list of batch_status pointers
        //
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_batch_status,0); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_attrl_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:attrl_name_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    {
        if (arg1->name) free(arg1->name);
        arg1->name = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->name,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attrl_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attrl_name_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    result = (char *) (arg1->name);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_attrl_resource_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:attrl_resource_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    {
        if (arg1->resource) free(arg1->resource);
        arg1->resource = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->resource,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attrl_resource_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attrl_resource_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    result = (char *) (arg1->resource);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_attrl_value_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:attrl_value_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    {
        if (arg1->value) free(arg1->value);
        arg1->value = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->value,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attrl_value_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attrl_value_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    result = (char *) (arg1->value);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_attrl_op_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    int arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:attrl_op_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    if (arg1) arg1->op = (enum batch_op)arg2;
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attrl_op_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attrl_op_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    result = (int ) (arg1->op);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


char *attrl___str__(struct attrl *self){
    static char temp[4 * 255] ;
    snprintf(temp, sizeof(temp), "(%s,%s,%s)", 
      self->name, self->resource, self->value);
    
    return &temp[0];
  }
static PyObject *_wrap_attrl___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attrl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attrl___str__",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    result = (char *)attrl___str__(arg1);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject * attrl_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_attrl, obj);
    Py_INCREF(obj);
    return Py_BuildValue("");
}
static PyObject *_wrap_attropl_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:attropl_name_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    {
        if (arg1->name) free(arg1->name);
        arg1->name = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->name,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attropl_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attropl_name_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    result = (char *) (arg1->name);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_attropl_resource_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:attropl_resource_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    {
        if (arg1->resource) free(arg1->resource);
        arg1->resource = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->resource,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attropl_resource_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attropl_resource_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    result = (char *) (arg1->resource);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_attropl_value_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:attropl_value_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    {
        if (arg1->value) free(arg1->value);
        arg1->value = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->value,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attropl_value_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attropl_value_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    result = (char *) (arg1->value);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_attropl_op_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    int arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:attropl_op_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    if (arg1) arg1->op = (enum batch_op)arg2;
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_attropl_op_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attropl_op_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    result = (int ) (arg1->op);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


char *attropl___str__(struct attropl *self){
    static char temp[4 * 255] ;
    snprintf(temp, sizeof(temp), "(%s,%s,%s)", 
      self->name, self->resource, self->value);
    
    return &temp[0];
  }
static PyObject *_wrap_attropl___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct attropl *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:attropl___str__",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_attropl,1)) == -1) return NULL;
    result = (char *)attropl___str__(arg1);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject * attropl_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_attropl, obj);
    Py_INCREF(obj);
    return Py_BuildValue("");
}
static PyObject *_wrap_batch_status_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:batch_status_name_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_batch_status,1)) == -1) return NULL;
    {
        if (arg1->name) free(arg1->name);
        arg1->name = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->name,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_batch_status_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:batch_status_name_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_batch_status,1)) == -1) return NULL;
    result = (char *) (arg1->name);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_batch_status_attribs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *arg1 ;
    struct attrl *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:batch_status_attribs_set",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_batch_status,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    if (arg1) arg1->attribs = arg2;
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_batch_status_attribs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *arg1 ;
    struct attrl *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:batch_status_attribs_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_batch_status,1)) == -1) return NULL;
    result = (struct attrl *) (arg1->attribs);
    {
        PyObject	*obj_batch;
        struct attrl	*ptr;
        int		i=0, len=0;
        
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_attrl,1); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_batch_status_text_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:batch_status_text_set",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_batch_status,1)) == -1) return NULL;
    {
        if (arg1->text) free(arg1->text);
        arg1->text = (char *) malloc(strlen(arg2)+1);
        strcpy(arg1->text,arg2);
    }Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_batch_status_text_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *arg1 ;
    char *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:batch_status_text_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_batch_status,1)) == -1) return NULL;
    result = (char *) (arg1->text);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject * batch_status_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_batch_status, obj);
    Py_INCREF(obj);
    return Py_BuildValue("");
}
static int _wrap_pbs_errno_set(PyObject *_val) {
    {
        long temp = PyInt_AsLong(_val);
        if (PyErr_Occurred()) {
            PyErr_SetString(PyExc_TypeError, "C variable 'pbs_errno (int )'");
            return 1;
        }
        pbs_errno = (int ) temp;
    }
    return 0;
}


static PyObject *_wrap_pbs_errno_get() {
    PyObject *pyobj;
    
    pyobj = PyInt_FromLong((long)pbs_errno);
    return pyobj;
}


static int _wrap_pbs_server_set(PyObject *_val) {
    {
        char *temp = (char *) PyString_AsString(_val);
        if (PyErr_Occurred()) {
            PyErr_SetString(PyExc_TypeError, "C variable 'pbs_server (char *)'");
            return 1;
        }
        if (pbs_server) free((char*) pbs_server);
        pbs_server = (char *) malloc(strlen(temp)+1);
        strcpy((char*)pbs_server,temp);
    }
    return 0;
}


static PyObject *_wrap_pbs_server_get() {
    PyObject *pyobj;
    
    pyobj = pbs_server ? PyString_FromString(pbs_server) : Py_BuildValue("");
    return pyobj;
}


static PyObject *_wrap_avail(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char result;
    
    if(!PyArg_ParseTuple(args,(char *)"is:avail",&arg1,&arg2)) return NULL;
    result = (char )avail(arg1,arg2);
    resultobj = Py_BuildValue("c",result);
    return resultobj;
}


static PyObject *_wrap_pbs_asyrunjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isss:pbs_asyrunjob",&arg1,&arg2,&arg3,&arg4)) return NULL;
    result = (int )pbs_asyrunjob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_alterjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    struct attrl *arg3 ;
    char *arg4 ;
    int result;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOs:pbs_alterjob",&arg1,&arg2,&obj2,&arg4)) return NULL;
    {
        PyObject	*py_obj;
        struct attrl	*ptr, *prev;
        char 		s[255];
        int		i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj2);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        
        arg3 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj2, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attrl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg3 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (int )pbs_alterjob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_connect(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:pbs_connect",&arg1)) return NULL;
    result = (int )pbs_connect(arg1);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_query_max_connections(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)":pbs_query_max_connections")) return NULL;
    result = (int )pbs_query_max_connections();
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_default(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)":pbs_default")) return NULL;
    result = (char *)pbs_default();
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_pbs_deljob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"iss:pbs_deljob",&arg1,&arg2,&arg3)) return NULL;
    result = (int )pbs_deljob(arg1,arg2,arg3);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_disconnect(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:pbs_disconnect",&arg1)) return NULL;
    result = (int )pbs_disconnect(arg1);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_geterrmsg(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:pbs_geterrmsg",&arg1)) return NULL;
    result = (char *)pbs_geterrmsg(arg1);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_pbs_holdjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isss:pbs_holdjob",&arg1,&arg2,&arg3,&arg4)) return NULL;
    result = (int )pbs_holdjob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_locjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"iss:pbs_locjob",&arg1,&arg2,&arg3)) return NULL;
    result = (char *)pbs_locjob(arg1,arg2,arg3);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_pbs_manager(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int arg3 ;
    char *arg4 ;
    struct attropl *arg5 ;
    char *arg6 ;
    int result;
    PyObject * obj4  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iiisOs:pbs_manager",&arg1,&arg2,&arg3,&arg4,&obj4,&arg6)) return NULL;
    {
        PyObject		*py_obj;
        struct attropl	*ptr, *prev;
        char 			s[255];
        int			i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj4);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        //printf("Size = %d\n", size);
        
        arg5 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj4, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attropl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg5 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (int )pbs_manager(arg1,arg2,arg3,arg4,arg5,arg6);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_movejob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isss:pbs_movejob",&arg1,&arg2,&arg3,&arg4)) return NULL;
    result = (int )pbs_movejob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_msgjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    int arg3 ;
    char *arg4 ;
    char *arg5 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isiss:pbs_msgjob",&arg1,&arg2,&arg3,&arg4,&arg5)) return NULL;
    result = (int )pbs_msgjob(arg1,arg2,arg3,arg4,arg5);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_orderjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isss:pbs_orderjob",&arg1,&arg2,&arg3,&arg4)) return NULL;
    result = (int )pbs_orderjob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_rescquery(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char **arg2 ;
    int arg3 ;
    int *arg4 ;
    int *arg5 ;
    int *arg6 ;
    int *arg7 ;
    int result;
    PyObject * obj1  = 0 ;
    PyObject * obj3  = 0 ;
    PyObject * obj4  = 0 ;
    PyObject * obj5  = 0 ;
    PyObject * obj6  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOiOOOO:pbs_rescquery",&arg1,&obj1,&arg3,&obj3,&obj4,&obj5,&obj6)) return NULL;
    {
        int		i=0, size=0;
        PyObject	*py_obj;
        
        size = Get_List_Size(obj1);
        
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        // printf("Size = %d\n", size);
        
        arg2 = (char **) malloc( (size+1) * sizeof(char *));
        for (i=0; i < size; i++) {
            py_obj = PyList_GetItem(obj1, i);
            if (PyString_Check(py_obj)) {
                arg2[i] = PyString_AsString(py_obj);
            }
            else {
                PyErr_SetString(PyExc_TypeError, "not a list of strings");
                free(arg2);
                return NULL; 
            }
        }// end for
        arg2[i] = 0;
    }
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_int,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_int,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj5,(void **) &arg6, SWIGTYPE_p_int,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj6,(void **) &arg7, SWIGTYPE_p_int,1)) == -1) return NULL;
    result = (int )pbs_rescquery(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    resultobj = PyInt_FromLong((long)result);
    {
        free( (char *) arg2);
    }
    return resultobj;
}


static PyObject *_wrap_pbs_rescreserve(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char **arg2 ;
    int arg3 ;
    resource_t *arg4 ;
    int result;
    PyObject * obj1  = 0 ;
    PyObject * obj3  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOiO:pbs_rescreserve",&arg1,&obj1,&arg3,&obj3)) return NULL;
    {
        int		i=0, size=0;
        PyObject	*py_obj;
        
        size = Get_List_Size(obj1);
        
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        // printf("Size = %d\n", size);
        
        arg2 = (char **) malloc( (size+1) * sizeof(char *));
        for (i=0; i < size; i++) {
            py_obj = PyList_GetItem(obj1, i);
            if (PyString_Check(py_obj)) {
                arg2[i] = PyString_AsString(py_obj);
            }
            else {
                PyErr_SetString(PyExc_TypeError, "not a list of strings");
                free(arg2);
                return NULL; 
            }
        }// end for
        arg2[i] = 0;
    }
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_resource_t,1)) == -1) return NULL;
    result = (int )pbs_rescreserve(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    {
        free( (char *) arg2);
    }
    return resultobj;
}


static PyObject *_wrap_pbs_rescrelease(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    resource_t arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:pbs_rescrelease",&arg1,&arg2)) return NULL;
    result = (int )pbs_rescrelease(arg1,arg2);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_rerunjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"iss:pbs_rerunjob",&arg1,&arg2,&arg3)) return NULL;
    result = (int )pbs_rerunjob(arg1,arg2,arg3);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_rlsjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isss:pbs_rlsjob",&arg1,&arg2,&arg3,&arg4)) return NULL;
    result = (int )pbs_rlsjob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_runjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isss:pbs_runjob",&arg1,&arg2,&arg3,&arg4)) return NULL;
    result = (int )pbs_runjob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_selectjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    struct attropl *arg2 ;
    char *arg3 ;
    char **result;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOs:pbs_selectjob",&arg1,&obj1,&arg3)) return NULL;
    {
        PyObject		*py_obj;
        struct attropl	*ptr, *prev;
        char 			s[255];
        int			i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj1);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        //printf("Size = %d\n", size);
        
        arg2 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj1, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attropl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg2 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (char **)pbs_selectjob(arg1,arg2,arg3);
    {
        int len=0, i;
        
        if (result == NULL) 
        resultobj = PyList_New(0);
        else {
            while (result[len]) 
            len++;
            
            resultobj = PyList_New(len);
            for (i=0; i < len; i++ )
            PyList_SetItem(resultobj, i , PyString_FromString(result[i])); 
        }
    }
    return resultobj;
}


static PyObject *_wrap_pbs_sigjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"isss:pbs_sigjob",&arg1,&arg2,&arg3,&arg4)) return NULL;
    result = (int )pbs_sigjob(arg1,arg2,arg3,arg4);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pbs_statfree(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    struct batch_status *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pbs_statfree",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_batch_status,1)) == -1) return NULL;
    pbs_statfree(arg1);
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pbs_statjob(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    struct attrl *arg3 ;
    char *arg4 ;
    struct batch_status *result;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOs:pbs_statjob",&arg1,&arg2,&obj2,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_attrl,1)) == -1) return NULL;
    result = (struct batch_status *)pbs_statjob(arg1,arg2,arg3,arg4);
    {
        PyObject *obj_batch;
        struct batch_status *ptr;
        int i=0, len=0;
        
        // printf("Ja we are in bussniss\n");
        
        // Deterime length of list
        //
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        // Make a list of batch_status pointers
        //
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_batch_status,0); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_pbs_selstat(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    struct attropl *arg2 ;
    char *arg3 ;
    struct batch_status *result;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOs:pbs_selstat",&arg1,&obj1,&arg3)) return NULL;
    {
        PyObject		*py_obj;
        struct attropl	*ptr, *prev;
        char 			s[255];
        int			i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj1);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        //printf("Size = %d\n", size);
        
        arg2 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj1, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attropl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg2 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (struct batch_status *)pbs_selstat(arg1,arg2,arg3);
    {
        PyObject *obj_batch;
        struct batch_status *ptr;
        int i=0, len=0;
        
        // printf("Ja we are in bussniss\n");
        
        // Deterime length of list
        //
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        // Make a list of batch_status pointers
        //
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_batch_status,0); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_pbs_statque(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    struct attrl *arg3 ;
    char *arg4 ;
    struct batch_status *result;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOs:pbs_statque",&arg1,&arg2,&obj2,&arg4)) return NULL;
    {
        PyObject	*py_obj;
        struct attrl	*ptr, *prev;
        char 		s[255];
        int		i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj2);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        
        arg3 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj2, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attrl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg3 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (struct batch_status *)pbs_statque(arg1,arg2,arg3,arg4);
    {
        PyObject *obj_batch;
        struct batch_status *ptr;
        int i=0, len=0;
        
        // printf("Ja we are in bussniss\n");
        
        // Deterime length of list
        //
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        // Make a list of batch_status pointers
        //
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_batch_status,0); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_pbs_statserver(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    struct attrl *arg2 ;
    char *arg3 ;
    struct batch_status *result;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOs:pbs_statserver",&arg1,&obj1,&arg3)) return NULL;
    {
        PyObject	*py_obj;
        struct attrl	*ptr, *prev;
        char 		s[255];
        int		i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj1);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        
        arg2 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj1, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attrl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg2 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (struct batch_status *)pbs_statserver(arg1,arg2,arg3);
    {
        PyObject *obj_batch;
        struct batch_status *ptr;
        int i=0, len=0;
        
        // printf("Ja we are in bussniss\n");
        
        // Deterime length of list
        //
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        // Make a list of batch_status pointers
        //
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_batch_status,0); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_pbs_statnode(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *arg2 ;
    struct attrl *arg3 ;
    char *arg4 ;
    struct batch_status *result;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"isOs:pbs_statnode",&arg1,&arg2,&obj2,&arg4)) return NULL;
    {
        PyObject	*py_obj;
        struct attrl	*ptr, *prev;
        char 		s[255];
        int		i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj2);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        
        arg3 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj2, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attrl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg3 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (struct batch_status *)pbs_statnode(arg1,arg2,arg3,arg4);
    {
        PyObject *obj_batch;
        struct batch_status *ptr;
        int i=0, len=0;
        
        // printf("Ja we are in bussniss\n");
        
        // Deterime length of list
        //
        ptr = result;
        while (ptr != NULL) {
            len++;
            ptr = ptr->next;
        }
        resultobj = PyList_New(len);
        
        // Make a list of batch_status pointers
        //
        ptr = result;
        for (i=0; i < len; i++) {
            obj_batch = SWIG_NewPointerObj((void *)ptr, SWIGTYPE_p_batch_status,0); 
            PyList_SetItem(resultobj, i, obj_batch);  	
            ptr = ptr->next;
        }
    }
    return resultobj;
}


static PyObject *_wrap_pbs_submit(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    struct attropl *arg2 ;
    char *arg3 ;
    char *arg4 ;
    char *arg5 ;
    char *result;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iOsss:pbs_submit",&arg1,&obj1,&arg3,&arg4,&arg5)) return NULL;
    {
        PyObject		*py_obj;
        struct attropl	*ptr, *prev;
        char 			s[255];
        int			i=0, size=0;
        
        // printf("Python --> C\n");
        
        size = Get_List_Size(obj1);
        if ( size == -1 ) {
            PyErr_SetString(PyExc_TypeError, "not a list");
            return NULL; 
        }
        //printf("Size = %d\n", size);
        
        arg2 = prev = NULL;
        for ( i=0; i < size; i++ ) {
            py_obj = PyList_GetItem(obj1, i);
            if (SWIG_ConvertPtr(py_obj, (void **) &ptr, SWIGTYPE_p_attropl, 1)) {
                sprintf(s,"list item %d has wrong type", i);
                PyErr_SetString(PyExc_TypeError, s);
                return NULL;
                
                // This will skipp the wrong entry
                // continue;
            }
            
            /*
            * Make first entry head of C linked list
            */ 
            if ( i == 0) {
                arg2 = ptr;
                ptr->next = prev;
            }
            else {
                prev->next = ptr;
                ptr->next = NULL;
            }
            prev = ptr;
            
        }// end for
    }
    result = (char *)pbs_submit(arg1,arg2,arg3,arg4,arg5);
    resultobj = result ? PyString_FromString(result) : Py_BuildValue("");
    return resultobj;
}


static PyObject *_wrap_pbs_terminate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    char *arg3 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"iis:pbs_terminate",&arg1,&arg2,&arg3)) return NULL;
    result = (int )pbs_terminate(arg1,arg2,arg3);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_totpool(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:totpool",&arg1,&arg2)) return NULL;
    result = (int )totpool(arg1,arg2);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_usepool(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:usepool",&arg1,&arg2)) return NULL;
    result = (int )usepool(arg1,arg2);
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"ptrvalue", _wrap_ptrvalue, METH_VARARGS },
	 { (char *)"ptrset", _wrap_ptrset, METH_VARARGS },
	 { (char *)"ptrcreate", _wrap_ptrcreate, METH_VARARGS },
	 { (char *)"ptrfree", _wrap_ptrfree, METH_VARARGS },
	 { (char *)"ptradd", _wrap_ptradd, METH_VARARGS },
	 { (char *)"new_attrl", _wrap_new_attrl, METH_VARARGS },
	 { (char *)"new_attropl", _wrap_new_attropl, METH_VARARGS },
	 { (char *)"new_batch_status", _wrap_new_batch_status, METH_VARARGS },
	 { (char *)"attrl_name_set", _wrap_attrl_name_set, METH_VARARGS },
	 { (char *)"attrl_name_get", _wrap_attrl_name_get, METH_VARARGS },
	 { (char *)"attrl_resource_set", _wrap_attrl_resource_set, METH_VARARGS },
	 { (char *)"attrl_resource_get", _wrap_attrl_resource_get, METH_VARARGS },
	 { (char *)"attrl_value_set", _wrap_attrl_value_set, METH_VARARGS },
	 { (char *)"attrl_value_get", _wrap_attrl_value_get, METH_VARARGS },
	 { (char *)"attrl_op_set", _wrap_attrl_op_set, METH_VARARGS },
	 { (char *)"attrl_op_get", _wrap_attrl_op_get, METH_VARARGS },
	 { (char *)"attrl___str__", _wrap_attrl___str__, METH_VARARGS },
	 { (char *)"attrl_swigregister", attrl_swigregister, METH_VARARGS },
	 { (char *)"attropl_name_set", _wrap_attropl_name_set, METH_VARARGS },
	 { (char *)"attropl_name_get", _wrap_attropl_name_get, METH_VARARGS },
	 { (char *)"attropl_resource_set", _wrap_attropl_resource_set, METH_VARARGS },
	 { (char *)"attropl_resource_get", _wrap_attropl_resource_get, METH_VARARGS },
	 { (char *)"attropl_value_set", _wrap_attropl_value_set, METH_VARARGS },
	 { (char *)"attropl_value_get", _wrap_attropl_value_get, METH_VARARGS },
	 { (char *)"attropl_op_set", _wrap_attropl_op_set, METH_VARARGS },
	 { (char *)"attropl_op_get", _wrap_attropl_op_get, METH_VARARGS },
	 { (char *)"attropl___str__", _wrap_attropl___str__, METH_VARARGS },
	 { (char *)"attropl_swigregister", attropl_swigregister, METH_VARARGS },
	 { (char *)"batch_status_name_set", _wrap_batch_status_name_set, METH_VARARGS },
	 { (char *)"batch_status_name_get", _wrap_batch_status_name_get, METH_VARARGS },
	 { (char *)"batch_status_attribs_set", _wrap_batch_status_attribs_set, METH_VARARGS },
	 { (char *)"batch_status_attribs_get", _wrap_batch_status_attribs_get, METH_VARARGS },
	 { (char *)"batch_status_text_set", _wrap_batch_status_text_set, METH_VARARGS },
	 { (char *)"batch_status_text_get", _wrap_batch_status_text_get, METH_VARARGS },
	 { (char *)"batch_status_swigregister", batch_status_swigregister, METH_VARARGS },
	 { (char *)"avail", _wrap_avail, METH_VARARGS },
	 { (char *)"pbs_asyrunjob", _wrap_pbs_asyrunjob, METH_VARARGS },
	 { (char *)"pbs_alterjob", _wrap_pbs_alterjob, METH_VARARGS },
	 { (char *)"pbs_connect", _wrap_pbs_connect, METH_VARARGS },
	 { (char *)"pbs_query_max_connections", _wrap_pbs_query_max_connections, METH_VARARGS },
	 { (char *)"pbs_default", _wrap_pbs_default, METH_VARARGS },
	 { (char *)"pbs_deljob", _wrap_pbs_deljob, METH_VARARGS },
	 { (char *)"pbs_disconnect", _wrap_pbs_disconnect, METH_VARARGS },
	 { (char *)"pbs_geterrmsg", _wrap_pbs_geterrmsg, METH_VARARGS },
	 { (char *)"pbs_holdjob", _wrap_pbs_holdjob, METH_VARARGS },
	 { (char *)"pbs_locjob", _wrap_pbs_locjob, METH_VARARGS },
	 { (char *)"pbs_manager", _wrap_pbs_manager, METH_VARARGS },
	 { (char *)"pbs_movejob", _wrap_pbs_movejob, METH_VARARGS },
	 { (char *)"pbs_msgjob", _wrap_pbs_msgjob, METH_VARARGS },
	 { (char *)"pbs_orderjob", _wrap_pbs_orderjob, METH_VARARGS },
	 { (char *)"pbs_rescquery", _wrap_pbs_rescquery, METH_VARARGS },
	 { (char *)"pbs_rescreserve", _wrap_pbs_rescreserve, METH_VARARGS },
	 { (char *)"pbs_rescrelease", _wrap_pbs_rescrelease, METH_VARARGS },
	 { (char *)"pbs_rerunjob", _wrap_pbs_rerunjob, METH_VARARGS },
	 { (char *)"pbs_rlsjob", _wrap_pbs_rlsjob, METH_VARARGS },
	 { (char *)"pbs_runjob", _wrap_pbs_runjob, METH_VARARGS },
	 { (char *)"pbs_selectjob", _wrap_pbs_selectjob, METH_VARARGS },
	 { (char *)"pbs_sigjob", _wrap_pbs_sigjob, METH_VARARGS },
	 { (char *)"pbs_statfree", _wrap_pbs_statfree, METH_VARARGS },
	 { (char *)"pbs_statjob", _wrap_pbs_statjob, METH_VARARGS },
	 { (char *)"pbs_selstat", _wrap_pbs_selstat, METH_VARARGS },
	 { (char *)"pbs_statque", _wrap_pbs_statque, METH_VARARGS },
	 { (char *)"pbs_statserver", _wrap_pbs_statserver, METH_VARARGS },
	 { (char *)"pbs_statnode", _wrap_pbs_statnode, METH_VARARGS },
	 { (char *)"pbs_submit", _wrap_pbs_submit, METH_VARARGS },
	 { (char *)"pbs_terminate", _wrap_pbs_terminate, METH_VARARGS },
	 { (char *)"totpool", _wrap_totpool, METH_VARARGS },
	 { (char *)"usepool", _wrap_usepool, METH_VARARGS },
	 { NULL, NULL }
};

#ifdef __cplusplus
}
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_batch_status[] = {{"_p_batch_status", 0, "struct batch_status *"},{"_p_batch_status"},{0}};
static swig_type_info _swigt__p_resource_t[] = {{"_p_resource_t", 0, "resource_t *"},{"_p_resource_t"},{"_p_int"},{0}};
static swig_type_info _swigt__p_float[] = {{"_p_float", 0, "float *"},{"_p_float"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *"},{"_p_double"},{0}};
static swig_type_info _swigt__p_char[] = {{"_p_char", 0, "char *"},{"_p_char"},{0}};
static swig_type_info _swigt__p_p_char[] = {{"_p_p_char", 0, "char **"},{"_p_p_char"},{0}};
static swig_type_info _swigt__p_attropl[] = {{"_p_attropl", 0, "attropl *"},{"_p_attropl"},{0}};
static swig_type_info _swigt__p_long[] = {{"_p_long", 0, "long *"},{"_p_long"},{0}};
static swig_type_info _swigt__p_attrl[] = {{"_p_attrl", 0, "struct attrl *"},{"_p_attrl"},{0}};
static swig_type_info _swigt__p_void[] = {{"_p_void", 0, "void *"},{"_p_void"},{0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *"},{"_p_resource_t"},{"_p_int"},{0}};
static swig_type_info _swigt__p_short[] = {{"_p_short", 0, "short *"},{"_p_short"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_batch_status, 
_swigt__p_resource_t, 
_swigt__p_float, 
_swigt__p_double, 
_swigt__p_char, 
_swigt__p_p_char, 
_swigt__p_attropl, 
_swigt__p_long, 
_swigt__p_attrl, 
_swigt__p_void, 
_swigt__p_int, 
_swigt__p_short, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{ SWIG_PY_STRING,  (char*)"ATTR_a", 0, 0, (void *)"Execution_Time", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_c", 0, 0, (void *)"Checkpoint", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_e", 0, 0, (void *)"Error_Path", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_g", 0, 0, (void *)"group_list", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_h", 0, 0, (void *)"Hold_Types", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_j", 0, 0, (void *)"Join_Path", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_k", 0, 0, (void *)"Keep_Files", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_l", 0, 0, (void *)"Resource_List", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_m", 0, 0, (void *)"Mail_Points", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_o", 0, 0, (void *)"Output_Path", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_p", 0, 0, (void *)"Priority", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_q", 0, 0, (void *)"destination", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_r", 0, 0, (void *)"Rerunable", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_u", 0, 0, (void *)"User_List", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_v", 0, 0, (void *)"Variable_List", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_A", 0, 0, (void *)"Account_Name", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_M", 0, 0, (void *)"Mail_Users", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_N", 0, 0, (void *)"Job_Name", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_S", 0, 0, (void *)"Shell_Path_List", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_depend", 0, 0, (void *)"depend", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_inter", 0, 0, (void *)"interactive", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_stagein", 0, 0, (void *)"stagein", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_stageout", 0, 0, (void *)"stageout", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_ctime", 0, 0, (void *)"ctime", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_exechost", 0, 0, (void *)"exec_host", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_mtime", 0, 0, (void *)"mtime", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_qtime", 0, 0, (void *)"qtime", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_session", 0, 0, (void *)"session_id", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_euser", 0, 0, (void *)"euser", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_egroup", 0, 0, (void *)"egroup", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_hashname", 0, 0, (void *)"hashname", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_hopcount", 0, 0, (void *)"hop_count", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_security", 0, 0, (void *)"security", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_sched_hint", 0, 0, (void *)"sched_hint", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_substate", 0, 0, (void *)"substate", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_name", 0, 0, (void *)"Job_Name", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_owner", 0, 0, (void *)"Job_Owner", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_used", 0, 0, (void *)"resources_used", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_state", 0, 0, (void *)"job_state", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_queue", 0, 0, (void *)"queue", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_server", 0, 0, (void *)"server", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_maxrun", 0, 0, (void *)"max_running", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_total", 0, 0, (void *)"total_jobs", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_comment", 0, 0, (void *)"comment", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_cookie", 0, 0, (void *)"cookie", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_qrank", 0, 0, (void *)"queue_rank", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_altid", 0, 0, (void *)"alt_id", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_etime", 0, 0, (void *)"etime", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_aclgren", 0, 0, (void *)"acl_group_enable", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_aclgroup", 0, 0, (void *)"acl_groups", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_aclhten", 0, 0, (void *)"acl_host_enable", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_aclhost", 0, 0, (void *)"acl_hosts", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_acluren", 0, 0, (void *)"acl_user_enable", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_acluser", 0, 0, (void *)"acl_users", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_altrouter", 0, 0, (void *)"alt_router", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_chkptmin", 0, 0, (void *)"checkpoint_min", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_enable", 0, 0, (void *)"enabled", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_fromroute", 0, 0, (void *)"from_route_only", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_killdelay", 0, 0, (void *)"kill_delay", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_maxgrprun", 0, 0, (void *)"max_group_run", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_maxque", 0, 0, (void *)"max_queuable", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_maxuserrun", 0, 0, (void *)"max_user_run", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_qtype", 0, 0, (void *)"queue_type", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rescassn", 0, 0, (void *)"resources_assigned", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rescdflt", 0, 0, (void *)"resources_default", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rescmax", 0, 0, (void *)"resources_max", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rescmin", 0, 0, (void *)"resources_min", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rndzretry", 0, 0, (void *)"rendezvous_retry", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_routedest", 0, 0, (void *)"route_destinations", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_routeheld", 0, 0, (void *)"route_held_jobs", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_routewait", 0, 0, (void *)"route_waiting_jobs", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_routeretry", 0, 0, (void *)"route_retry_time", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_routelife", 0, 0, (void *)"route_lifetime", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rsvexpdt", 0, 0, (void *)"reserved_expedite", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rsvsync", 0, 0, (void *)"reserved_sync", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_start", 0, 0, (void *)"started", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_count", 0, 0, (void *)"state_count", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_number", 0, 0, (void *)"number_jobs", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_aclroot", 0, 0, (void *)"acl_roots", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_managers", 0, 0, (void *)"managers", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_dfltque", 0, 0, (void *)"default_queue", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_defnode", 0, 0, (void *)"default_node", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_locsvrs", 0, 0, (void *)"location_servers", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_logevents", 0, 0, (void *)"log_events", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_logfile", 0, 0, (void *)"log_file", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_mailfrom", 0, 0, (void *)"mail_from", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_nodepack", 0, 0, (void *)"node_pack", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_operators", 0, 0, (void *)"operators", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_queryother", 0, 0, (void *)"query_other_jobs", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_resccost", 0, 0, (void *)"resources_cost", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_rescavail", 0, 0, (void *)"resources_available", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_schedit", 0, 0, (void *)"scheduler_iteration", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_scheduling", 0, 0, (void *)"scheduling", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_status", 0, 0, (void *)"server_state", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_syscost", 0, 0, (void *)"system_cost", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_NODE_state", 0, 0, (void *)"state", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_NODE_np", 0, 0, (void *)"np", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_NODE_properties", 0, 0, (void *)"properties", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_NODE_ntype", 0, 0, (void *)"ntype", 0},
{ SWIG_PY_STRING,  (char*)"ATTR_NODE_jobs", 0, 0, (void *)"jobs", 0},
{ SWIG_PY_STRING,  (char*)"CHECKPOINT_UNSPECIFIED", 0, 0, (void *)"u", 0},
{ SWIG_PY_STRING,  (char*)"NO_HOLD", 0, 0, (void *)"n", 0},
{ SWIG_PY_STRING,  (char*)"NO_JOIN", 0, 0, (void *)"n", 0},
{ SWIG_PY_STRING,  (char*)"NO_KEEP", 0, 0, (void *)"n", 0},
{ SWIG_PY_STRING,  (char*)"MAIL_AT_ABORT", 0, 0, (void *)"a", 0},
{ SWIG_PY_STRING,  (char*)"DELDELAY", 0, 0, (void *)"deldelay=", 0},
{ SWIG_PY_STRING,  (char*)"USER_HOLD", 0, 0, (void *)"u", 0},
{ SWIG_PY_STRING,  (char*)"OTHER_HOLD", 0, 0, (void *)"o", 0},
{ SWIG_PY_STRING,  (char*)"SYSTEM_HOLD", 0, 0, (void *)"s", 0},
{ SWIG_PY_STRING,  (char*)"ND_free", 0, 0, (void *)"free", 0},
{ SWIG_PY_STRING,  (char*)"ND_offline", 0, 0, (void *)"offline", 0},
{ SWIG_PY_STRING,  (char*)"ND_down", 0, 0, (void *)"down", 0},
{ SWIG_PY_STRING,  (char*)"ND_reserve", 0, 0, (void *)"reserve", 0},
{ SWIG_PY_STRING,  (char*)"ND_job_exclusive", 0, 0, (void *)"job-exclusive", 0},
{ SWIG_PY_STRING,  (char*)"ND_job_sharing", 0, 0, (void *)"job-sharing", 0},
{ SWIG_PY_STRING,  (char*)"ND_busy", 0, 0, (void *)"busy", 0},
{ SWIG_PY_STRING,  (char*)"ND_state_unknown", 0, 0, (void *)"state-unknown", 0},
{ SWIG_PY_STRING,  (char*)"ND_timeshared", 0, 0, (void *)"time-shared", 0},
{ SWIG_PY_STRING,  (char*)"ND_cluster", 0, 0, (void *)"cluster", 0},
{ SWIG_PY_INT,     (char *)"MAX_ENCODE_BFR", (long) 100, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_CMD_CREATE", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_CMD_DELETE", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_CMD_SET", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_CMD_UNSET", (long) 3, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_CMD_LIST", (long) 4, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_CMD_PRINT", (long) 5, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_CMD_ACTIVE", (long) 6, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_OBJ_NONE", (long) -1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_OBJ_SERVER", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_OBJ_QUEUE", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_OBJ_JOB", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MGR_OBJ_NODE", (long) 3, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MSG_OUT", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MSG_ERR", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"SHUT_SIG", (long) -1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"SHUT_IMMEDIATE", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"SHUT_DELAY", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"SHUT_QUICK", (long) 2, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"SIG_RESUME", 0, 0, (void *)"resume", 0},
{ SWIG_PY_STRING,  (char*)"SIG_SUSPEND", 0, 0, (void *)"suspend", 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXHOSTNAME", (long) 64, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MAXPATHLEN", (long) 1024, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"MAXNAMLEN", (long) 255, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXUSER", (long) 16, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXGRPN", (long) 16, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXQUEUENAME", (long) 15, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXSERVERNAME", (long) 64, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXSEQNUM", (long) 6, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXPORTNUM", (long) 5, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXSVRJOBID", (long) (6+64+5+2), 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXCLTJOBID", (long) ((6+64+5+2)+64+5+2), 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXDEST", (long) 256, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_MAXROUTEDEST", (long) (15+64+5+2), 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_USE_IFF", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_INTERACTIVE", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_TERM_BUF_SZ", (long) 80, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"PBS_TERM_CCA", (long) 6, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"PBS_BATCH_SERVICE_NAME", 0, 0, (void *)"pbs", 0},
{ SWIG_PY_INT,     (char *)"PBS_BATCH_SERVICE_PORT", (long) 15001, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"PBS_BATCH_SERVICE_NAME_DIS", 0, 0, (void *)"pbs_dis", 0},
{ SWIG_PY_INT,     (char *)"PBS_BATCH_SERVICE_PORT_DIS", (long) 15001, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"PBS_MOM_SERVICE_NAME", 0, 0, (void *)"pbs_mom", 0},
{ SWIG_PY_INT,     (char *)"PBS_MOM_SERVICE_PORT", (long) 15002, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"PBS_MANAGER_SERVICE_NAME", 0, 0, (void *)"pbs_resmon", 0},
{ SWIG_PY_INT,     (char *)"PBS_MANAGER_SERVICE_PORT", (long) 15003, 0, 0, 0},
{ SWIG_PY_STRING,  (char*)"PBS_SCHEDULER_SERVICE_NAME", 0, 0, (void *)"pbs_sched", 0},
{ SWIG_PY_INT,     (char *)"PBS_SCHEDULER_SERVICE_PORT", (long) 15004, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"SET", (long) SET, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"UNSET", (long) UNSET, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INCR", (long) INCR, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DECR", (long) DECR, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"EQ", (long) EQ, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"NE", (long) NE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GE", (long) GE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GT", (long) GT, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"LE", (long) LE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"LT", (long) LT, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DFLT", (long) DFLT, 0, 0, 0},
{0}};


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0;
    PyObject *m, *d;
    int       i;
    SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    SWIG_POINTER_int_p = SWIG_TypeQuery("int *");
    SWIG_POINTER_short_p = SWIG_TypeQuery("short *");
    SWIG_POINTER_long_p = SWIG_TypeQuery("long *");
    SWIG_POINTER_float_p = SWIG_TypeQuery("float *");
    SWIG_POINTER_double_p = SWIG_TypeQuery("double *");
    SWIG_POINTER_char_p = SWIG_TypeQuery("char *");
    SWIG_POINTER_char_pp = SWIG_TypeQuery("char **");
    
    PyDict_SetItemString(d,(char*)"cvar", SWIG_globals);
    SWIG_addvarlink(SWIG_globals,(char*)"pbs_errno",_wrap_pbs_errno_get, _wrap_pbs_errno_set);
    SWIG_addvarlink(SWIG_globals,(char*)"pbs_server",_wrap_pbs_server_get, _wrap_pbs_server_set);
}

